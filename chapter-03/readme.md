# 코드에서 나는 악취

이 장에서는 언제 리팩터링을 시작하고 그만할지에 대한 내용을 다룬다. 프로그래밍을 하면서 발생할 수 있는 악취들에 대해 어떤 케이스가 있고 어떤 식의 리팩터링을 진행해야할지에 대한 가이드라인을 제시해준다. 실제 내가 만든 코드에서 케이스 별의 예제를 생각하거나 찾으면서 하니 좀 더 이해가 잘 됐던 거 같다. 앞으로 코딩할 때 더 많은 생각을 갖고 하게 될 거 같다. 경험하고 연습하고 정리하다보면 더 성장할 수 있을거란 확신이 든다.

### 3.1 기이한 이름

![1](./images/1.png)
이름을 잘 짓는 것은 단순히 표현의 문제로 끝나지 않는다. 이름을 잘 짓는 것만으로 코드의 이해가 쉬워지며, 마땅한 이름이 떠오르지 않는다는 것 설계에 근본적인 문제가 있음을 암시할 수도 있다.

### 3.2 중복 코드

코드의 중복은 수정할 때 큰 리스크를 갖는다. 공통 로직이 있다면, 함수로 분리하거나 슈퍼 클래스의 메소드로 올리는 등의 방법을 이용하여 중복되는 부분을 최대한 없애보자

### 3.3 긴 함수

과거와 다르게 현대에는 함수를 호출하는 비용의 거의 없다시피 하다. 함수를 잘게 쪼개두면 왔다갔다하면서 읽는 귀찮음이 생길 수 있지만 그마저도 이름을 잘 지어두면 함수의 내부를 볼 이유는 사라지게 된다. 특히 주석이나 설명이 필요한 코드는 함수로 분리하여 코드가 무엇을 하는지를 명확히 나타낼 수 있도록 하자.

### 3.4 긴 매개변수 목록

매개변수 목록이 길어지면 이해하기 힘들어진다. 별도의 매개변수 객체나 클래스를 이용하여 긴 매개변수를 줄여보자.

### 3.5 전역 데이터

변수의 접근 범위는 항상 필요한만큼 최소한으로 유지하자. 특히 가변 전역 데이터를 남용한다면 디버깅이 매우 힘들어질 것이다.

### 3.6 가변 데이터

변수가 어디서나 수정될 수 있다면 이는 예상치 못한 결과를 낳기 쉽다. 데이터는 불변으로 다루거나 함수나 메소드를 통해서만 수정할 수 있게 한다면 데이터가 변경됨에 따라 생기는 부작용을 최소화 할 수 있을 곳이다.

### 3.7 뒤엉킨 변경(Divergent Change)

단일 책임 원칙이 지켜지지 않았기 때문에 생기는 경우이다. 단계를 나누고 함수를 분리하여 코드의 책임을 맥락 별로 잘 분리해두자.

### 3.8 산탄총 수술

뒤엉킨 변경과 반대의 경우이다. 동작을 변경하기 위해 여러 부분들을 찾아서 수정해야한다. 이 경우에는 책임과 맥락에 맞춰 코드를 모아주도록 하자.

### 3.9 기능 편애

프로그램을 모듈화 할 때는 여러 영역으로 나뉘어져 영역 내부의 상호작용을 최대로, 영역 간의 상호작용은 최소로 하는 것이 이롭다.. 어떤 함수가 다른 모듈의 함수나 데이터와 더 많이 상호작용한다면, 해당 함수를 분리하거나 옮겨주도록 하자.

### 3.10 데이터 뭉치

항상 같이 다뤄지는 데이터는 **클래스**로 모아보자. 처음에는 단순히 멤버변수만 있는 클래스이지만, 해당 데이터들이 갖는 행동과 책임을 메소드로 선언할 수 있는 기회가 주어진다. 즉 일종의 VO(Value Object)로서 비즈니스 로직을 갖는 진정한 도메인 모델로 거듭나게 될 것이다.

### 3.11 기본형 집착

전화번호, 화폐, 좌표 등등 분명한 형식과 의미를 갖는 데이터임에도 불구하고 우리는 프로그래밍 언어가 제공해주는 기본 타입만을 이용하여 이런 데이터를 다룰 때가 많다. 이를 객체 또는 클래스로 바꿔보자.

### 3.12 반복되는 switch문

모든 switch문과 if문 같은 조건부 로직이 다형성을 이용한 리팩터링의 대상인 것만은 아니다. 그러나 조건이 추가될 때마다 다른 곳도도 찾아서 똑같이 수정해줘야는 경우논 다형성으로 참교육해주도록 하자.

### 3.13 반복문

단순 반복문 대신 filter, map같은 파이프라인 연산으로 코드의 의도를 더 명확히 드러내자.

### 3.14 성의 없는 요소

작업이나 리팩터링의 결과로 역할이 충분히 줄어든 요소들은 미래를 위한다는 명분 하에 남겨두기보다는 인라인 등을 이용해 없애주도록 하자. 그러나 내 생각에 이 작업은 해당 분야의 도메인 지식 뒷밤침되어야하는 작업이라고 생각한다. 분리되는 것이 맞는 개념에 대한 코드인지, 리팩터링의 잔재물과 같은 코드인지는 개발자가 스스로 판단하는 것이다.

### 3.15 추측성 일반화

_나중에 필요할거야_ 라는 명분 하에 흩뿌려둔 코드는 당장 걸리적거리는 경우가 대부분이다. 날려버리도록 하자.

### 3.16 임시 필드

특정 상황에만 값이 설정되는 클래스가 있을 것이다. 이는 코드의 동작을 이해하기 위한 추가적인 노력을 요구하게 되므로 클래스로 필드와 로직들을 분리해주자.

### 3.17 메세지 체인

```javascript
const managerName = aPerson.department.manager.name;
```

위와 같은 코드는 중간의 department나 manager 객체가 수정되었을 때 관련 코드를 모두 찾아 고쳐줘야하는 위험을 앉고 있다.

```javascript
class aPerson {
  ...
  get managerName() {
    return this.department.manager.name
  }
...
}
```

위와 같이 이런 메세지 체인을 숨겨준다면 혹시 수정이 발생되더라도 aPerson클래스의 managerName getter만 수정하면 다른 부분을 찾아서 고쳐줄 필요가 사라지게 된다.

### 3.18 중개자

위의 내용과 반대되는 내용이다. 위임 객체의 멤버를 가져올 때마다 위처럼 메소드를 추가한다면 해당 클래스는 본래의 책임보다 위임 메소드가 더 많은 단순 중개자 클래스가 되어버릴 수도 있다.
어느 정도의 위임이 적정할지는 도메인 지식과 경험의 뒷받침으로 판단해야할 것이며 서비스가 변경되면서 적정의 기준이 바뀔 수도 있다. 그럴 땐 그저 다시 리팩터링을 해주면 그만이다.

### 3.19 내부자 거래

모듈간의 데이터 거래는 최소로, 투명하게 처리하자. 만약 그렇지 않다면, 서브 클래스나 슈퍼 클래스를 위임 객체로 바꾸거나 새로운 모듈을 만들어서 모듈간의 관심사 공유 빈도를 줄요보자.

### 3.20 거대한 클래스

보통 한 클래스에서 너무 많을 일을 하려다보면 필드 수가 많아지고 중복이 늘어나기 마련이다. 클래스를 분리하거나 해당 클래스 내에서 자체적으로 중복을 제거해보자.

### 3.21 서로 다른 인터페이스의 대안 클래스들

클래스들은 언제든지 다른 클래스 교체될 수 있다는 것이 큰 장점이다. 단, **인터페이스는 동일해야한다**.

### 3.22 데이터 클래스

데이터 클래스는 필드와 getter/setter로만 구성된 클래스를 의미한다. 이는 필요한 동작이 엉뚱한 곳에 정의되어있을 수 있다는 신호일 수 있으므로, 해당 데이터 클래스가 갖는 책임이 외부에 구현되어있지는 않은지 살펴보자.

### 3.23 상속 포기

우리는 종종 부모클래스의 필드와 메소드를 원치 않는 서브클래스를 만들기도 한다. 이것 자체는 큰 문제가 아닐 수 있으며 실무 관점에서는 유용할 수도 있다. 그러나 인터페이스를 따르지 않는 것은 넘어갈 수 없다. 이런 경우 클래스 위임을 이용해 아예 상속메커니즘에서 벗어나게끔 해보자.

### 3.24 주석

주석은 보통 향기를 풍긴다. 그렇다고 주석이 탈취제가 되는 것은 아니다. 주석이 장황하게 달린 원인은 애당초 코드를 잘못 작성했기 때문인 경우가 많다. 함수 추출, 이름 변경 등등의 **리팩터링 기법을 적극적으로 활용하여 주석이 필요없는 코드로 바꿔보자.**
